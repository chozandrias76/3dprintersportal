/* eslint no-undefined: 0 */

let assign;

if (typeof Object.assign === 'function') {
  assign = Object.assign;
} else {
  assign = function (target) {
    if (target === undefined || target === null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    const output = Object(target);

    const propertyObjects = [].slice.call(arguments, 1);

    if (propertyObjects.length > 0) {
      propertyObjects.forEach(source => {
        if (source !== undefined && source !== null) {
          let nextKey;

          for (nextKey in source) {
            if (source.hasOwnProperty(nextKey)) {
              output[nextKey] = source[nextKey];
            }
          }
        }
      });
    }

    return output;
  };
}

var assign$1 = assign;

let includes;

if (!Array.prototype.includes) {
  includes = function (array, searchElement) {
    const ObjectifiedArray = Object(array);
    const length = parseInt(ObjectifiedArray.length, 10) || 0;

    if (length === 0) {
      return false;
    }

    const startIndex = parseInt(arguments[2], 10) || 0;
    let index;

    if (startIndex >= 0) {
      index = startIndex;
    } else {
      index = length + startIndex;

      if (index < 0) {
        index = 0;
      }
    }

    while (index < length) {
      const currentElement = ObjectifiedArray[index];

      /* eslint no-self-compare:0 */
      if (searchElement === currentElement || searchElement !== searchElement && currentElement !== currentElement) {
        // NaN !== NaN
        return true;
      }
      index++;
    }

    return false;
  };
} else {
  includes = function (array) {
    const args = [].slice.call(arguments, 1);

    return Array.prototype.includes.apply(array, args);
  };
}

var includes$1 = includes;

function wrap(func, superFunc) {
  function superWrapper() {
    const originalSuper = this['super'];

    this['super'] = function () {
      return superFunc.apply(this, arguments);
    };

    const ret = func.apply(this, arguments);

    this['super'] = originalSuper;

    return ret;
  }

  superWrapper.wrappedFunction = func;

  return superWrapper;
}

function defineProperties(names, proto, destination) {
  const parentProto = Object.getPrototypeOf(destination);

  names.forEach(function (name) {
    const descriptor = Object.getOwnPropertyDescriptor(proto, name);
    const parentDescriptor = parentProto.hasOwnProperty(name) && Object.getOwnPropertyDescriptor(parentProto, name);

    if (typeof parentDescriptor.value === 'function' && typeof descriptor.value === 'function') {
      const wrappedFunction = wrap(descriptor.value, parentDescriptor.value);

      Object.defineProperty(destination, name, { value: wrappedFunction });
    } else {
      Object.defineProperty(destination, name, descriptor);
    }
  });
}

function createClass(props, parent = Object) {
  const Constructor = wrap(props.constructor, parent);
  const instancePropertyNames = Object.getOwnPropertyNames(props).filter(key => {
    return !includes$1(['constructor', 'static'], key);
  });

  assign$1(Constructor, parent);

  Constructor.prototype = Object.create(parent.prototype);
  defineProperties(instancePropertyNames, props, Constructor.prototype);
  Constructor.prototype.constructor = Constructor;

  const staticProps = props['static'];

  if (staticProps) {
    const staticPropertyNames = Object.getOwnPropertyNames(staticProps);

    defineProperties(staticPropertyNames, staticProps, Constructor);
  }

  return Constructor;
}

const CoreObject = createClass({
  constructor() {},

  'static': {
    extend(subClassProps) {
      return createClass(subClassProps, this);
    }
  }
});

function wrapConsole(logCommand) {
  const logMethod = function () {
    let log;

    /* eslint-disable no-console */
    if (console[logCommand]) {
      log = Function.prototype.bind.call(console[logCommand], console);
    } else {
      log = Function.prototype.bind.call(console.log, console);
    }
    log(...arguments);
    /* eslint-enable no-console */
  };

  return function () {
    const args = [...arguments];

    args.unshift('[JS-BUY-SDK]: ');
    logMethod(...args);
  };
}

const Logger = CoreObject.extend({
  /**
   * Wrapper around the console log so in the future we can have better dev output.
   * Also allows us to disable output in production.
   * @private
   * @class Logger
   * @constructor
   */
  constructor() {},
  debug: wrapConsole('debug'),
  info: wrapConsole('info'),
  warn: wrapConsole('warn'),
  error: wrapConsole('error')
});

var logger = new Logger();

const Config = CoreObject.extend({
  constructor(attrs) {
    Object.keys(this.deprecatedProperties).forEach(key => {
      if (attrs.hasOwnProperty(key)) {
        const transformName = this.deprecatedProperties[key];
        const transform = this[transformName];

        transform(attrs[key], attrs);
      }
    });
    this.requiredProperties.forEach(key => {
      if (!attrs.hasOwnProperty(key)) {
        throw new Error(`new Config() requires the option '${ key }'`);
      } else {
        this[key] = attrs[key];
      }
    });
  },

  /**
   * An object with keys for deprecated properties and values as functions that
   * will transform the value into a usable value. A depracation transform should
   * have the value signature function(deprecated_value, config_to_be_transformed)
   * @attribute deprecatedProperties
   * @default { myShopifyDomain: this.transformMyShopifyDomain }
   * @type Object
   * @private
   */
  deprecatedProperties: {
    myShopifyDomain: 'transformMyShopifyDomain'
  },

  /**
   * Transform the myShopifyDomain config to a domain config.
   * @method transformMyShopifyDomain
   * @static
   * @private
   * @param {String} subdomain The original subdomain on myshopify.com
   * @param {Object} attrs. The config attributes to be transformed to a
   * non-deprecated state.
   * @return {Object} the transformed config attributes.
   */
  transformMyShopifyDomain(subdomain, attrs) {
    logger.warn('Config - ', 'myShopifyDomain is deprecated, please use domain and provide the full shop domain.');
    attrs.domain = `${ subdomain }.myshopify.com`;
  },

  /**
   * Properties that must be set on initializations
   * @attribute requiredProperties
   * @default ['apiKey', 'appId', 'myShopifyDomain']
   * @type Array
   * @private
   */
  requiredProperties: ['apiKey', 'appId', 'domain'],

  /**
   * The apiKey for authenticating against shopify. This is your api client's
   * public api token. Not the shared secret. Set during initialation.
   * @attribute apiKey
   * @default ''
   * @type String
   * @private
   */
  apiKey: '',

  /**
   * @attribute appId
   * @default ''
   * @type String
   * @private
   */
  appId: '',

  /**
   * The domain that all the api requests will go to
   * @attribute domain
   * @default ''
   * @type String
   * @private
   */
  domain: '',

  /**
   * The subdomain of myshopify.io that all the api requests will go to
   * @attribute myShopifyDomain
   * @default ''
   * @type String
   * @private
   * @deprecated Use `config.domain` instead.
   */
  myShopifyDomain: ''
});

const version = 'v0.5.1-e503716'; // eslint-disable-line

const BaseModel = CoreObject.extend({
  constructor(attrs = {}, metaAttrs = {}) {
    this.attrs = attrs;

    assign$1(this, metaAttrs);
  },
  attrs: null,
  serializer: null,
  adapter: null,
  shopClient: null
});

/**
  * Class for product option
  * @class ProductOptionModel
  * @constructor
*/
const ProductOptionModel = BaseModel.extend(Object.defineProperties({
  constructor() {
    this['super'](...arguments);

    this.selected = this.values[0];
  }

}, {
  name: {
    /**
      * name of option. Example values: `"Size"`, `"Color"`, etc.
      * @property name
      * @readOnly
      * @type String
    */
    get: function () {
      return this.attrs.name;
    },
    configurable: true,
    enumerable: true
  },
  values: {

    /**
      * an Array possible values for option. For instance if this option is a "Size" option an example value
      * for values could be: `["Large", "Medium", "Small"]`
      *
      * @property values
      * @readOnly
      * @type Array
    */
    get: function () {
      return this.attrs.values;
    },
    configurable: true,
    enumerable: true
  },
  selected: {

    /**
      * get/set the currently selected option value with one of the values from the
      * {{#crossLink "ProductOptionModel/values"}}ProductOptionModel.values{{/crossLink}} array. For
      * instance if the option values array had the following `["Large", "Medium", "Small"]` setting `selected` to be
      * `"Large"`, `"Medium"`, or `"Small"` would be valid any other value would throw an `Error`.
      *
      * @property selected
      * @type String
    */
    get: function () {
      return this._selected;
    },
    set: function (value) {
      if (includes$1(this.values, value)) {
        this._selected = value;
      } else {
        throw new Error(`Invalid option selection for ${ this.name }.`);
      }

      return value;
    },
    configurable: true,
    enumerable: true
  }
}));

/**
  * Model for product variant
  * @class ProductVariantModel
  * @constructor
*/
const ProductVariantModel = BaseModel.extend(Object.defineProperties({
  constructor() {
    this['super'](...arguments);
  },

  /**
    * Get a checkout url for a specific product variant. You can
    * optionally pass a quantity. If no quantity is passed then quantity
    * will default to 1. The example below will grab a checkout url for
    * 3 copies of the first variant:
    * ```
    * const checkoutURL = product.variants[ 0 ].checkoutUrl(3);
    * ```
    *
    * @method checkoutUrl
    * @param {Number} [quantity = 1] quantity of variants
    * @public
    * @return {String} Checkout URL
  */
  checkoutUrl(quantity = 1) {
    const config = this.config;
    const baseUrl = `https://${ config.domain }/cart`;

    const variantPath = `${ this.id }:${ parseInt(quantity, 10) }`;

    const query = `api_key=${ config.apiKey }`;

    return `${ baseUrl }/${ variantPath }?${ query }`;
  }
}, {
  id: {
    /**
      * Variant unique ID
      * @property id
      * @type {String}
    */
    get: function () {
      return this.attrs.variant.id;
    },
    configurable: true,
    enumerable: true
  },
  productId: {

    /**
      * ID of product variant belongs to
      * @property productId
      * @type {String}
    */
    get: function () {
      return this.attrs.product.id;
    },
    configurable: true,
    enumerable: true
  },
  title: {

    /**
      * Title of variant
      * @property title
      * @type {String}
    */
    get: function () {
      return this.attrs.variant.title;
    },
    configurable: true,
    enumerable: true
  },
  productTitle: {

    /**
      * Title of product variant belongs to
      * @property productTitle
      * @type {String}
    */
    get: function () {
      return this.attrs.product.title;
    },
    configurable: true,
    enumerable: true
  },
  compareAtPrice: {

    /**
      * Compare at price for variant. The `compareAtPrice` would be
      * the price of the product previously before the product went on sale. For more info
      * go <a href="https://docs.shopify.com/manual/products/promoting-marketing/sales" target="_blank">here</a>.
      *
      * If no `compareAtPrice` is set then this value will be `null`. An example value: `"5.00"`
      * @property compareAtPrice
      * @type {String}
    */
    get: function () {
      return this.attrs.variant.compare_at_price;
    },
    configurable: true,
    enumerable: true
  },
  price: {

    /**
      * Price of the variant. The price will be in the following form: `"10.00"`
      *
      * @property price
      * @type {String}
    */
    get: function () {
      return this.attrs.variant.price;
    },
    configurable: true,
    enumerable: true
  },
  formattedPrice: {

    /**
      * Price of variant, formatted according to shop currency format string.
      * For instance `"$10.00"`
      *
      * @property formattedPrice
      * @type {String}
    */
    get: function () {
      return this.attrs.variant.formatted_price;
    },
    configurable: true,
    enumerable: true
  },
  grams: {

    /**
      * Variant weight in grams. If no weight is defined grams will be `0`.
      * @property grams
      * @type {Number}
    */
    get: function () {
      return this.attrs.variant.grams;
    },
    configurable: true,
    enumerable: true
  },
  optionValues: {

    /**
      * Option values associated with this variant. Example `optionValues`:
      * ```
      * [
      *   {
      *     "name": "Size",
      *     "option_id": 9165336518,
      *     "value": "small"
      *   },
      *   {
      *     "name": "Color",
      *     "option_id": 9640532358,
      *     "value": "blue"
      *   }
      * ]
      * ````
      *
      * @property optionValues
      * @type {Array|Object}
    */
    get: function () {
      return this.attrs.variant.option_values;
    },
    configurable: true,
    enumerable: true
  },
  available: {

    /**
      * Variant in stock. Always `true` if inventory tracking is disabled.
      * @property available
      * @type {Boolean}
    */
    get: function () {
      return this.attrs.variant.available;
    },
    configurable: true,
    enumerable: true
  },
  image: {

    /**
      * Image for variant. An example image `Object`:
      * ```
      * {
      *   created_at: "2016-08-29T12:35:09-04:00",
      *   id: 17690553350,
      *   position: 1,
      *   product_id: 8291029446,
      *   src: "https://cdn.shopify.com/s/files/1/1019/0495/products/i11_c3334325-2d67-4623-8cd4-0a6b08aa1b83.jpg?v=1472488509",
      *   updated_at: "2016-08-29T12:35:09-04:00",
      *   variant_ids: [ 27690103238 ]
      * }
      * ```
      *
      * @property image
      * @type {Object}
    */
    get: function () {
      const id = this.id;
      const images = this.attrs.product.images;

      const primaryImage = images[0];
      const variantImage = images.filter(image => {
        return image.variant_ids.indexOf(id) !== -1;
      })[0];

      return variantImage || primaryImage;
    },
    configurable: true,
    enumerable: true
  },
  imageVariants: {

    /**
      * Image variants available for a variant. An example value of `imageVariant`:
      * ```
      * [
      *   {
      *     "name": "pico",
      *     "dimensions": "16x16",
      *     "src": "https://cdn.shopify.com/s/files/1/1019/0495/products/alien_146ef7c1-26e9-4e96-96e6-9d37128d0005_pico.jpg?v=1469046423"
      *   },
      *   {
      *     "name": "compact",
      *     "dimensions": "160x160",
      *     "src": "https://cdn.shopify.com/s/files/1/1019/0495/products/alien_146ef7c1-26e9-4e96-96e6-9d37128d0005_compact.jpg?v=1469046423"
      *   }
      * ]
      * ```
      *
      * @property imageVariant
      * @type {Array}
    */
    get: function () {
      const image = this.image;

      if (!image) {
        return [];
      }

      const src = this.image.src;
      const extensionIndex = src.lastIndexOf('.');
      const pathAndBasename = src.slice(0, extensionIndex);
      const extension = src.slice(extensionIndex);
      const variants = [{ name: 'pico', dimension: '16x16' }, { name: 'icon', dimension: '32x32' }, { name: 'thumb', dimension: '50x50' }, { name: 'small', dimension: '100x100' }, { name: 'compact', dimension: '160x160' }, { name: 'medium', dimension: '240x240' }, { name: 'large', dimension: '480x480' }, { name: 'grande', dimension: '600x600' }, { name: '1024x1024', dimension: '1024x1024' }, { name: '2048x2048', dimension: '2048x2048' }];

      variants.forEach(variant => {
        variant.src = `${ pathAndBasename }_${ variant.name }${ extension }`;
      });

      return variants;
    },
    configurable: true,
    enumerable: true
  }
}));

var uniq = function (array) {
  return array.reduce(function (uniqueArray, item) {
    if (uniqueArray.indexOf(item) < 0) {
      uniqueArray.push(item);
    }

    return uniqueArray;
  }, []);
};

const NO_IMAGE_URI = 'https://widgets.shopifyapps.com/assets/no-image.svg';

/**
   * Class for products returned by fetch('product')
   * @class ProductModel
   * @constructor
 */
const ProductModel = BaseModel.extend(Object.defineProperties({
  constructor() {
    this['super'](...arguments);
  }

}, {
  id: {
    /**
      * Product unique ID
      *
      * @property id
      * @type {String}
    */
    get: function () {
      return this.attrs.product_id;
    },
    configurable: true,
    enumerable: true
  },
  title: {

    /**
      * The product title
      * @property title
      * @type {String}
    */
    get: function () {
      return this.attrs.title;
    },
    configurable: true,
    enumerable: true
  },
  description: {

    /**
      * A product description.
      * @property description
      * @type {String}
    */
    get: function () {
      return this.attrs.body_html;
    },
    configurable: true,
    enumerable: true
  },
  images: {

    /**
      * An `Array` of `Objects` that contain meta data about an image including `src` of the images.
      *
      * An example image `Object`:
      * ```
      * {
      *   created_at: "2016-08-29T12:35:09-04:00",
      *   id: 17690553350,
      *   position: 1,
      *   product_id: 8291029446,
      *   src: "https://cdn.shopify.com/s/files/1/1019/0495/products/i11_c3334325-2d67-4623-8cd4-0a6b08aa1b83.jpg?v=1472488509",
      *   updated_at: "2016-08-29T12:35:09-04:00",
      *   variant_ids: [ 27690103238 ]
      * }
      * ```
      * @property images
      * @type {Array} array of image objects.
    */
    get: function () {
      return this.attrs.images;
    },
    configurable: true,
    enumerable: true
  },
  memoized: {
    get: function () {
      this._memoized = this._memoized || {};

      return this._memoized;
    },
    configurable: true,
    enumerable: true
  },
  options: {

    /**
     *  Get an array of {{#crossLink "ProductOptionModel"}}ProductOptionModels{{/crossLink}}.
     *  {{#crossLink "ProductOptionModel"}}ProductOptionModels{{/crossLink}} can be used to
     *  define the currently `selectedVariant` from which you can get a checkout url
     *  ({{#crossLink "ProductVariantModel/checkoutUrl"}}ProductVariantModel.checkoutUrl{{/crossLink}}) or can
     *  be added to a cart ({{#crossLink "CartModel/createLineItemsFromVariants"}}CartModel.createLineItemsFromVariants{{/crossLink}}).
     *
     *  Below is an example on how to create html for option selections:
     * ```javascript
     *  // the following will create an Array of HTML to create multiple select inputs
     *  // global callbacks are also created which will set the option as selected
     *  var elements = product.options.map(function(option) {
     *    // we'll create a callback in global scope
     *    // which will be called when the select's value changes
     *    var callBackName = option.name + 'onChange';
     *    window[ callBackName ] = function(select) {
     *      // set the products option to be selected
     *      option.selected = select.value;
     *    };
     *
     *    // return a string which will be HTML for the select
     *    return '<select name="' + option.name + '" onchange="'callBackName'(this)">' + option.values.map(function(value) {
     *      return '<option value="' + value + '">' + value + '</option>';
     *    }) + '</select>';
     *  });
     * ```
     *
     * @property options
     * @type {Array|ProductOptionModel}
     */
    get: function () {
      if (this.memoized.options) {
        return this.memoized.options;
      }

      const baseOptions = this.attrs.options;
      const variants = this.variants;

      this.memoized.options = baseOptions.map(option => {
        const name = option.name;

        const dupedValues = variants.reduce((valueList, variant) => {
          const optionValueForOption = variant.optionValues.filter(optionValue => {
            return optionValue.name === option.name;
          })[0];

          valueList.push(optionValueForOption.value);

          return valueList;
        }, []);

        const values = uniq(dupedValues);

        return new ProductOptionModel({ name, values });
      });

      return this.memoized.options;
    },
    configurable: true,
    enumerable: true
  },
  variants: {

    /**
      * An `Array` of {{#crossLink "ProductVariantModel"}}ProductVariantModel's{{/crossLink}}
      * @property variants
      * @type {Array|ProductVariantModel} array of ProductVariantModel instances.
    */
    get: function () {
      return this.attrs.variants.map(variant => {
        return new ProductVariantModel({ variant, product: this }, { config: this.config });
      });
    },
    configurable: true,
    enumerable: true
  },
  selections: {

    /**
      * A read only `Array` of Strings represented currently selected option values. eg. `["Large", "Red"]`
      * @property selections
      * @type {Array | String}
    */
    get: function () {
      return this.options.map(option => {
        return option.selected;
      });
    },
    configurable: true,
    enumerable: true
  },
  selectedVariant: {

    /**
      * Retrieve variant for currently selected options. By default the first value in each
      * option is selected which means `selectedVariant` will never be `null`.
      *
      * With a `selectedVariant` you can create checkout url
      * ({{#crossLink "ProductVariantModel/checkoutUrl"}}ProductVariantModel.checkoutUrl{{/crossLink}}) or it can
      * be added to a cart ({{#crossLink "CartModel/createLineItemsFromVariants"}}CartModel.createLineItemsFromVariants{{/crossLink}}).
      *
      * @property selectedVariant
      * @type {ProductVariantModel}
    */
    get: function () {
      const variantTitle = this.selections.join(' / ');

      return this.variants.filter(variant => {
        return variant.title === variantTitle;
      })[0] || null;
    },
    configurable: true,
    enumerable: true
  },
  selectedVariantImage: {

    /**
      * Retrieve image for currently selected variantImage. An example image Object would look like this:
      * ```
      * {
      *   created_at: "2016-08-29T12:35:09-04:00",
      *   id: 17690553350,
      *   position: 1,
      *   product_id: 8291029446,
      *   src: "https://cdn.shopify.com/s/files/1/1019/0495/products/i11_c3334325-2d67-4623-8cd4-0a6b08aa1b83.jpg?v=1472488509",
      *   updated_at: "2016-08-29T12:35:09-04:00",
      *   variant_ids: [ 27690103238 ]
      * }
      * ```
      *
      * @property selectedVariantImage
      * @type {Object}
    */
    get: function () {
      if (!this.selectedVariant) {
        return null;
      }

      return this.selectedVariant.image;
    },
    configurable: true,
    enumerable: true
  }
}));

const ListingsSerializer = CoreObject.extend({
  constructor(config) {
    this.config = config;
  },

  rootKeyForType(type) {
    return `${ type.slice(0, -1) }_listing`;
  },

  models: {
    collections: BaseModel,
    products: ProductModel
  },

  modelForType(type) {
    return this.models[type];
  },

  deserializeSingle(type, singlePayload = {}, metaAttrs = {}) {
    const modelAttrs = singlePayload[this.rootKeyForType(type)];
    const model = this.modelFromAttrs(type, modelAttrs, metaAttrs);

    return model;
  },

  deserializeMultiple(type, collectionPayload = {}, metaAttrs = {}) {
    const models = collectionPayload[`${ this.rootKeyForType(type) }s`];

    return models.map(attrs => {
      const model = this.modelFromAttrs(type, attrs, metaAttrs);

      return model;
    });
  },

  modelFromAttrs(type, attrs, metaAttrs) {
    const Model = this.modelForType(type);

    metaAttrs.config = this.config;

    return new Model(attrs, metaAttrs);
  }
});

function authToUrl(url, opts) {
  let authorization;

  if (opts.headers) {
    Object.keys(opts.headers).forEach(key => {
      if (key.toLowerCase() === 'authorization') {
        authorization = opts.headers[key];
      }
    });
  }

  if (authorization) {
    const hashedKey = authorization.split(' ').slice(-1)[0];

    try {
      const plainKey = atob(hashedKey);

      let newUrl;

      if (url.indexOf('?') > -1) {
        newUrl = `${ url }&_x_http_authorization=${ plainKey }`;
      } else {
        newUrl = `${ url }?_x_http_authorization=${ plainKey }`;
      }

      return newUrl;
    } catch (e) {
      // atob choked on non-encoded data. Therefore, not a form of auth we
      // support.
      //
      // NOOP
      //
    }
  }

  /* eslint newline-before-return: 0 */
  return url;
}

function ie9Ajax(method, url, opts) {
  return new Promise(function (resolve, reject) {
    const xdr = new XDomainRequest();

    xdr.onload = function () {
      try {
        const json = JSON.parse(xdr.responseText);

        resolve({ json, originalResponse: xdr, isJSON: true });
      } catch (e) {
        resolve({ text: xdr.responseText, originalResponse: xdr, isText: true });
      }
    };

    function handleError() {
      reject(new Error('There was an error with the XDR'));
    }

    xdr.onerror = handleError;
    xdr.ontimeout = handleError;

    xdr.open(method, authToUrl(url, opts));
    xdr.send(opts.data);
  });
}

function isNodeLikeEnvironment() {
  const windowAbsent = typeof window === 'undefined';
  const requirePresent = typeof require === 'function';

  return windowAbsent && requirePresent;
}

function checkStatus(response) {
  if (response.status >= 200 && response.status < 300) {
    return response;
  }

  const error = new Error(response.statusText);

  error.status = response.status;
  error.response = response;
  throw error;
}

function parseResponse(response) {
  return response.json().then(json => {
    return { json, originalResponse: response, isJSON: true };
  })['catch'](() => {
    const responseClone = response.clone();

    return responseClone.text().then(text => {
      return { text, originalResponse: responseClone, isText: true };
    });
  });
}

function ajax(method, url, opts = {}) {
  // we need to check that we're not running in Node
  // before we should check if this is ie9
  if (!isNodeLikeEnvironment()) {
    const xhr = new XMLHttpRequest();

    if (!('withCredentials' in xhr)) {
      return ie9Ajax(...arguments);
    }
  }

  opts.method = method;
  opts.mode = 'cors';

  return fetch(url, opts).then(checkStatus).then(parseResponse);
}

const ListingsAdapter = CoreObject.extend(Object.defineProperties({
  ajax,

  constructor(config) {
    this.config = config;
  },

  pathForType(type) {
    return `/${ type.slice(0, -1) }_listings`;
  },

  buildUrl(singleOrMultiple, type, idOrQuery) {
    switch (singleOrMultiple) {
      case 'multiple':
        return this.buildMultipleUrl(type, idOrQuery);
      case 'single':
        return this.buildSingleUrl(type, idOrQuery);
      default:
        return '';
    }
  },

  buildMultipleUrl(type, query = {}) {
    const url = `${ this.baseUrl }${ this.pathForType(type) }`;
    const paramNames = Object.keys(query);

    if (paramNames.length > 0) {
      const queryString = paramNames.map(key => {
        let value;

        if (Array.isArray(query[key])) {
          value = query[key].join(',');
        } else {
          value = query[key];
        }

        return `${ key }=${ encodeURIComponent(value) }`;
      }).join('&');

      return `${ url }?${ queryString }`;
    }

    return url;
  },

  buildSingleUrl(type, id) {
    return `${ this.baseUrl }${ this.pathForType(type) }/${ id }`;
  },

  fetchMultiple() /* type, [query] */{
    const url = this.buildUrl('multiple', ...arguments);

    return this.ajax('GET', url, { headers: this.headers }).then(response => {
      return response.json;
    });
  },

  fetchSingle() /* type, id */{
    const url = this.buildUrl('single', ...arguments);

    return this.ajax('GET', url, { headers: this.headers }).then(response => {
      return response.json;
    });
  }
}, {
  base64ApiKey: {
    get: function () {
      return btoa(this.config.apiKey);
    },
    configurable: true,
    enumerable: true
  },
  baseUrl: {
    get: function () {
      const { domain, appId } = this.config;

      return `https://${ domain }/api/apps/${ appId }`;
    },
    configurable: true,
    enumerable: true
  },
  headers: {
    get: function () {
      return {
        Authorization: `Basic ${ this.base64ApiKey }`,
        'Content-Type': 'application/json',
        'X-SDK-Variant': 'javascript',
        'X-SDK-Version': version

      };
    },
    configurable: true,
    enumerable: true
  }
}));

var GUID_KEY = 'shopify-buy-uuid';

/**
 * A cart stores an Array of `CartLineItemModel`'s in it's `lineItems` property.
 * @class CartLineItemModel
 * @constructor
 */
const CartLineItemModel = BaseModel.extend(Object.defineProperties({
  constructor() {
    this['super'](...arguments);
  }

}, {
  id: {
    /**
     * A line item ID.
     * @property id
     * @readOnly
     * @type {String}
     */
    get: function () {
      return this.attrs[GUID_KEY];
    },
    configurable: true,
    enumerable: true
  },
  variant_id: {

    /**
     * ID of line item variant.
     * @property variant_id
     * @readOnly
     * @type {String}
     */
    get: function () {
      return this.attrs.variant_id;
    },
    configurable: true,
    enumerable: true
  },
  product_id: {

    /**
     * ID of variant's product.
     * @property product_id
     * @readOnly
     * @type {String}
     */
    get: function () {
      return this.attrs.product_id;
    },
    configurable: true,
    enumerable: true
  },
  image: {

    /**
     * Variant's image.
     * Example `Object` returned:
     * ```
     * {
     *    "id": 18723183238,
     *    "created_at": "2016-09-14T17:12:12-04:00",
     *    "position": 1,
     *    "updated_at": "2016-09-14T17:12:12-04:00",
     *    "product_id": 8569911558,
     *    "src": "https://cdn.shopify.com/s/files/1/1019/0495/products/Mop__three_different_mop_handles.jpg?v=1473887532",
     *    "variant_ids": []
     *  }
     * ```
     * @property image
     * @readOnly
     * @type {Object}
     */
    get: function () {
      return this.attrs.image;
    },
    configurable: true,
    enumerable: true
  },
  imageVariants: {

    /**
      * Image variants available for a variant. An example value of `imageVariant`:
      * ```
      * [
      *   {
      *     "name": "pico",
      *     "dimensions": "16x16",
      *     "src": "https://cdn.shopify.com/s/files/1/1019/0495/products/alien_146ef7c1-26e9-4e96-96e6-9d37128d0005_pico.jpg?v=1469046423"
      *   },
      *   {
      *     "name": "compact",
      *     "dimensions": "160x160",
      *     "src": "https://cdn.shopify.com/s/files/1/1019/0495/products/alien_146ef7c1-26e9-4e96-96e6-9d37128d0005_compact.jpg?v=1469046423"
      *   }
      * ]
      * ```
      *
      * @property imageVariant
      * @type {Array}
    */
    get: function () {
      return this.attrs.image_variants;
    },
    configurable: true,
    enumerable: true
  },
  title: {

    /**
     * Product title of variant's parent product.
     * @property title
     * @readOnly
     * @type {String}
     */
    get: function () {
      return this.attrs.title;
    },
    configurable: true,
    enumerable: true
  },
  quantity: {

    /**
     * Count of variants to order.
     * @property quantity
     * @type {Number}
     */
    get: function () {
      return this.attrs.quantity;
    },
    set: function (value) {
      const parsedValue = parseInt(value, 10);

      if (parsedValue < 0) {
        throw new Error('Quantities must be positive');
      } else if (parsedValue !== parseFloat(value)) {
        /* incidentally, this covers all NaN values, because NaN !== Nan */
        throw new Error('Quantities must be whole numbers');
      }

      this.attrs.quantity = parsedValue;

      return this.attrs.quantity;
    },
    configurable: true,
    enumerable: true
  },
  properties: {

    /**
     * Customization information for a product.
     * <a href="https://help.shopify.com/themes/customization/products/get-customization-information-for-products" target="_blank">
     * See here for more info
     * </a>.
     * @property properties
     * @type {Object}
     * @private
     */
    get: function () {
      return this.attrs.properties || {};
    },
    set: function (value) {
      this.attrs.properties = value || {};

      return value;
    },
    configurable: true,
    enumerable: true
  },
  variant_title: {

    /**
     * Title of variant.
     * @property variant_title
     * @readOnly
     * @type {String}
     */
    get: function () {
      return this.attrs.variant_title;
    },
    configurable: true,
    enumerable: true
  },
  price: {

    /**
     * Price of the variant. For example: `"5.00"`.
     * @property price
     * @readOnly
     * @type {String}
     */
    get: function () {
      return this.attrs.price;
    },
    configurable: true,
    enumerable: true
  },
  compare_at_price: {

    /**
      * Compare at price for variant. The `compareAtPrice` would be
      * the price of the product previously before the product went on sale. For more info
      * go <a href="https://docs.shopify.com/manual/products/promoting-marketing/sales" target="_blank">here</a>.
      *
      * If no `compareAtPrice` is set then this value will be `null`. An example value: `"5.00"`.
      * @property compareAtPrice
      * @readOnly
      * @type {String}
    */
    get: function () {
      return this.attrs.compare_at_price;
    },
    configurable: true,
    enumerable: true
  },
  line_price: {

    /**
     * The total price for this line item. For instance if the variant costs `1.50` and you have a quantity
     * of 2 then `line_price` will be `3.00`.
     * @property line_price
     * @readOnly
     * @type {String}
     */
    get: function () {
      return (this.quantity * parseFloat(this.price)).toFixed(2);
    },
    configurable: true,
    enumerable: true
  },
  grams: {

    /**
     * Variant's weight in grams. If no weight is set then `0` is returned.
     * @property grams
     * @readOnly
     * @type {Number}
     */
    get: function () {
      return this.attrs.grams;
    },
    configurable: true,
    enumerable: true
  }
}));

/* eslint no-undefined: 0 complexity: 0 */
const GUID_PREFIX = `shopify-buy.${ Date.now() }`;

const GUID_DESC = {
  writable: true,
  configurable: true,
  enumerable: true,
  value: null
};

let uuidSeed = 0;

function uuid() {
  return ++uuidSeed;
}

const numberCache = {};
const stringCache = {};

function setGuidFor(obj) {
  if (obj && obj[GUID_KEY]) {
    return obj[GUID_KEY];
  }

  if (obj === undefined) {
    return '(undefined)';
  }

  if (obj === null) {
    return '(null)';
  }

  const type = typeof obj;
  let id;

  switch (type) {
    case 'number':
      id = numberCache[obj];

      if (!id) {
        id = numberCache[obj] = `nu${ obj }`;
      }

      break;

    case 'string':
      id = stringCache[obj];

      if (!id) {
        id = stringCache[obj] = `st${ uuid() }`;
      }

      break;

    case 'boolean':
      if (obj) {
        id = '(true)';
      } else {
        id = '(false)';
      }

      break;

    default:
      if (obj === Object) {
        id = '(Object)';
        break;
      }

      if (obj === Array) {
        id = '(Array)';
        break;
      }

      id = `${ GUID_PREFIX }.${ uuid() }`;

      if (obj[GUID_KEY] === null) {
        obj[GUID_KEY] = id;
      } else {
        GUID_DESC.value = id;
        Object.defineProperty(obj, GUID_KEY, GUID_DESC);
      }
  }

  return id;
}

/* global global */

let globalNamespace;

if (typeof global === 'undefined') {
  globalNamespace = window;
} else {
  globalNamespace = global;
}

function set(key, value) {
  if (!globalNamespace[key]) {
    globalNamespace[key] = value;
  }
}

function get(key) {
  return globalNamespace[key];
}

var globalVars = { set, get };

function objectsEqual(one, two) {
  if (one === two) {
    return true;
  }

  return Object.keys(one).every(key => {
    if (one[key] instanceof Date) {
      return one[key].toString() === two[key].toString();
    } else if (typeof one[key] === 'object') {
      return objectsEqual(one[key], two[key]);
    }

    return one[key] === two[key];
  });
}

/**
* Class for cart model
* @class CartModel
*/
const CartModel = BaseModel.extend(Object.defineProperties({
  constructor() {
    this['super'](...arguments);
  },

  /**
    * Add items to the cart. Updates cart's `lineItems` based on variants passed in.
    * ```javascript
    * cart.addVariants({variant: variantObject, quantity: 1}).then(cart => {
    *   // the cart has created line items
    * });
    * ```
    * @deprecated `createLineItemsFromVariants` will be used in the future as it's more descriptive
    * @method addVariants
    * @param {Object} item - One or more variants
    * @param {ProductVariantModel} item.variant - variant object
    * @param {Number} item.quantity - quantity
    * @param {Object} [moreItems...] - further objects defining `variant` and `quantity` maybe passed in
    * @private
    * @return {Promise|CartModel} - the cart instance.
  */
  addVariants() {
    logger.warn('CartModel - ', 'addVariants is deprecated, please use createLineItemsFromVariants instead');

    return this.createLineItemsFromVariants(...arguments);
  },

  /**
    * Add items to the cart. Updates cart's `lineItems` based on variants passed in.
    * ```javascript
    * cart.createLineItemsFromVariants({variant: variantObject, quantity: 1}).then(cart => {
    *   // the cart has created line items
    * });
    * ```
    * @method createLineItemsFromVariants
    * @param {Object} item - One or more variants
    * @param {ProductVariantModel} item.variant - variant object
    * @param {Number} item.quantity - quantity
    * @param {Object} [moreItems...] - further objects defining `variant` and `quantity` maybe passed in
    * @public
    * @return {Promise|CartModel} - the cart instance.
  */
  createLineItemsFromVariants() {
    const newLineItems = [...arguments].map(item => {
      const lineItem = {
        image: item.variant.image,
        image_variants: item.variant.imageVariants,
        variant_id: item.variant.id,
        product_id: item.variant.productId,
        title: item.variant.productTitle,
        quantity: parseInt(item.quantity, 10),
        properties: item.properties || {},
        variant_title: item.variant.title,
        price: item.variant.price,
        compare_at_price: item.variant.compareAtPrice,
        grams: item.variant.grams
      };

      setGuidFor(lineItem);

      return lineItem;
    });
    const existingLineItems = this.attrs.line_items;

    existingLineItems.push(...newLineItems);

    const dedupedLineItems = existingLineItems.reduce((itemAcc, item) => {
      const matchingItem = itemAcc.filter(existingItem => {
        return existingItem.variant_id === item.variant_id && objectsEqual(existingItem.properties, item.properties);
      })[0];

      if (matchingItem) {
        matchingItem.quantity = matchingItem.quantity + item.quantity;
      } else {
        itemAcc.push(item);
      }

      return itemAcc;
    }, []);

    // Users may pass negative numbers and remove items. This ensures there's no
    // item with a quantity of zero or less.
    this.attrs.line_items = dedupedLineItems.reduce((itemAcc, item) => {
      if (item.quantity >= 1) {
        itemAcc.push(item);
      }

      return itemAcc;
    }, []);

    return this.updateModel();
  },

  /**
    * Update a line item quantity based on line item id
    * ```javascript
    * // This example changes the quantity for the first line item to 2
    * const firstLineItemId = cart.lineItems[0].id;
    *
    * cart.updateLineItem(firstLineItemId, 2).then(cart => {
    *   // the cart has updated the line item
    * });
    * ```
    * @method updateLineItem
    * @param {String} id - line item ID
    * @param {Number} quantity - new quantity for line item
    * @throws {Error} if line item with ID is not in cart.
    * @public
    * @return {Promise|CartModel} - the cart instance
  */
  updateLineItem(id, quantity) {
    if (quantity < 1) {
      return this.removeLineItem(id);
    }

    const lineItem = this.lineItems.filter(item => {
      return item.id === id;
    })[0];

    if (lineItem) {
      lineItem.quantity = quantity;

      return this.updateModel();
    }

    return new Promise(function (resolve, reject) {
      reject(new Error(`line item with id: ${ id } not found in cart#${ this.id }`));
    });
  },

  /**
    * Remove a line item from cart based on line item id
    * ```javascript
    * // This example removes the first line item
    * const firstLineItemId = cart.lineItems[0].id;
    *
    * cart.removeLineItem(firstLineItemId).then(cart => {
    *   // the cart has removed the line item
    * });
    * ```
    *
    * @method removeLineItem
    * @param {String} id - line item ID
    * @throws {Error} if line item with ID is not in cart.
    * @public
    * @return {Promise|CartModel} - the cart instance
  */
  removeLineItem(id) {
    const oldLength = this.lineItems.length;
    const newLineItems = this.lineItems.filter(item => {
      return item.id !== id;
    });
    const newLength = newLineItems.length;

    if (newLength < oldLength) {
      this.attrs.line_items = newLineItems.map(item => {
        return item.attrs;
      });

      return this.updateModel();
    }

    return new Promise(function (resolve, reject) {
      reject(new Error(`line item with id: ${ id } not found in cart#${ this.id }`));
    });
  },

  /**
    * Remove all line items from cart
    * ```javascript
    * // This example removes all line items from the cart
    * cart.clearLineItems().then(cart => {
    *   // the cart has removed all line items
    * });
    * @method clearLineItems
    * @public
    * @return {Promise|CartModel} - the cart instance
  */
  clearLineItems() {
    this.attrs.line_items = [];

    return this.updateModel();
  },

  /**
    * Force update of cart model on server. This function will only be used in advanced situations and does not need to be called
    * explicitly to update line items. It is automatically called after
    * {{#crossLink "CartModel/createLineItemsFromVariants"}}{{/crossLink}},
    * {{#crossLink "CartModel/updateLineItem"}}{{/crossLink}},
    * {{#crossLink "CartModel/removeLineItem"}}{{/crossLink}},
    * and {{#crossLink "CartModel/removeLineItem"}}{{/crossLink}}
    *
    * @method updateModel
    * @public
    * @return {Promise|CartModel} - the cart instance
  */
  updateModel() {
    return this.shopClient.update('carts', this).then(updateCart => {
      assign$1(this.attrs, updateCart.attrs);

      return this;
    });
  }
}, {
  id: {
    /**
      * get ID for current cart
      * @property id
      * @readOnly
      * @type {String}
    */
    get: function () {
      return this.attrs[GUID_KEY];
    },
    configurable: true,
    enumerable: true
  },
  lineItems: {

    /**
      * Get an `Array` of {{#crossLink "CartLineItemModel"}}CartLineItemModel's{{/crossLink}}
      * @property lineItems
      * @readOnly
      * @type {Array}
    */
    get: function () {
      return (this.attrs.line_items || []).map(item => {
        return new CartLineItemModel(item);
      });
    },
    configurable: true,
    enumerable: true
  },
  lineItemCount: {

    /**
      * Gets the total quantity of all line items. Example: you've added two variants with quantities 3 and 2. `lineItemCount` will be 5.
      * @property lineItemCount
      * @readOnly
      * @type {Number}
    */
    get: function () {
      return this.lineItems.reduce(function (total, item) {
        return total + item.quantity;
      }, 0);
    },
    configurable: true,
    enumerable: true
  },
  subtotal: {

    /**
      * Get current subtotal price for all line items. Example: two items have been added to the cart that cost $1.25
      * then the subtotal will be `2.50`
      *
      * @property subtotal
      * @readOnly
      * @type {String}
    */
    get: function () {
      const subtotal = this.lineItems.reduce((runningTotal, lineItem) => {
        return runningTotal + parseFloat(lineItem.line_price);
      }, 0);

      return subtotal.toFixed(2);
    },
    configurable: true,
    enumerable: true
  },
  checkoutUrl: {

    /**
      * Get checkout URL for current cart
      * @property checkoutUrl
      * @readOnly
      * @type {String}
    */
    get: function () {
      const config = this.config;
      const baseUrl = `https://${ config.domain }/cart`;
      const ga = globalVars.get('ga');

      const variantPath = this.lineItems.map(item => {
        return `${ item.variant_id }:${ item.quantity }`;
      });

      let query = `api_key=${ config.apiKey }&_fd=0`;

      if (typeof ga === 'function') {
        let linkerParam;

        ga(function (tracker) {
          linkerParam = tracker.get('linkerParam');
        });

        if (linkerParam) {
          query += `&${ linkerParam }`;
        }
      }

      return `${ baseUrl }/${ variantPath }?${ query }`;
    },
    configurable: true,
    enumerable: true
  }
}));

const CartSerializer = CoreObject.extend({
  constructor(config) {
    this.config = config;
  },

  rootKeyForType(type) {
    return type.slice(0, -1);
  },

  modelForType() /* type */{
    return CartModel;
  },

  deserializeSingle(type, singlePayload = {}, metaAttrs = {}) {
    const modelAttrs = singlePayload[this.rootKeyForType(type)];
    const model = this.modelFromAttrs(type, modelAttrs, metaAttrs);

    return model;
  },

  modelFromAttrs(type, attrs, metaAttrs) {
    const Model = this.modelForType(type);

    metaAttrs.config = this.config;

    return new Model(attrs, metaAttrs);
  },

  serialize(type, model) {
    const root = this.rootKeyForType(type);
    const payload = {};
    const attrs = assign$1({}, model.attrs);

    payload[root] = attrs;

    delete attrs.attributes;

    Object.keys(attrs).forEach(key => {
      const value = attrs[key];

      if (value === null || typeof value === 'string' && value.length === 0) {
        delete attrs[key];
      }
    });

    return payload;
  }
});

const ReferenceModel = BaseModel.extend(Object.defineProperties({

  /**
    * Class for reference model
    * @private
    * @class ReferenceModel
    * @constructor
  */
  constructor(attrs) {
    if (Object.keys(attrs).indexOf('referenceId') < 0) {
      throw new Error('Missing key referenceId of reference. References to null are not allowed');
    }

    this['super'](...arguments);
  }

}, {
  id: {
    /**
      * get the ID for current reference (not what it refers to, but its own unique identifier)
      * @property id
      * @type {String}
    */
    get: function () {
      return this.attrs[GUID_KEY];
    },
    configurable: true,
    enumerable: true
  },
  referenceId: {
    get: function () {
      return this.attrs.referenceId;
    },
    set: function (value) {
      this.attrs.referenceId = value;

      return value;
    },
    configurable: true,
    enumerable: true
  }
}));

const ReferenceSerializer = CoreObject.extend({
  constructor(config) {
    this.config = config;
  },

  modelForType() /* type */{
    return ReferenceModel;
  },

  deserializeSingle(type, singlePayload = {}, metaAttrs = {}) {
    const Model = this.modelForType(type);

    return new Model(singlePayload, metaAttrs);
  },

  serialize(type, model) {
    const attrs = assign$1({}, model.attrs);

    return attrs;
  }
});

const Store = CoreObject.extend({
  constructor() {
    this.localStorageAvailable = this.storageAvailable('localStorage');
    this.cache = {};
  },

  setItem(key, value) {
    if (this.localStorageAvailable) {
      localStorage.setItem(key, JSON.stringify(value));
    } else {
      this.cache[key] = value;
    }

    return value;
  },

  getItem(key) {
    if (this.localStorageAvailable) {
      const stringValue = localStorage.getItem(key);

      try {
        return JSON.parse(stringValue);
      } catch (e) {
        return null;
      }
    } else {
      return this.cache[key] || null;
    }
  },

  storageAvailable(type) {
    try {
      const storage = globalVars.get(type);
      const x = '__storage_test__';

      storage.setItem(x, x);
      storage.removeItem(x);

      return true;
    } catch (e) {
      return false;
    }
  }
});

const LocalStorageAdapter = CoreObject.extend({
  constructor() {
    this.store = new Store();
  },

  idKeyForType() /* type */{
    return GUID_KEY;
  },

  fetchSingle(type, id) {
    return new Promise((resolve, reject) => {
      const value = this.store.getItem(this.storageKey(type, id));

      if (value === null) {
        reject(new Error(`${ type }#${ id } not found`));

        return;
      }

      resolve(value);
    });
  },

  create(type, payload) {
    return new Promise(resolve => {
      const id = this.identify(payload);

      this.store.setItem(this.storageKey(type, id), payload);
      resolve(payload);
    });
  },

  update(type, id, payload) {
    return new Promise(resolve => {
      this.store.setItem(this.storageKey(type, id), payload);
      resolve(payload);
    });
  },

  storageKey(type, id) {
    return `${ type }.${ id }`;
  },

  identify(payload) {
    const keys = Object.keys(payload);

    if (keys.length === 1 && typeof payload[keys[0]] === 'object') {
      return setGuidFor(payload[keys[0]]);
    }

    return setGuidFor(payload);
  }
});

/**
 * @module shopify-buy
 * @submodule shop-client
 */

function fetchFactory(fetchType, type) {
  let func;

  switch (fetchType) {
    case 'all':
      func = function () {
        return this.fetchAll(type);
      };
      break;
    case 'one':
      func = function () {
        return this.fetch(type, ...arguments);
      };
      break;
    case 'query':
      func = function () {
        return this.fetchQuery(type, ...arguments);
      };
      break;
  }

  return func;
}

const ShopClient = CoreObject.extend(Object.defineProperties({
  /**
   * @class ShopClient
   * @constructor
   */
  constructor(config) {
    this.config = config;

    this.serializers = {
      products: ListingsSerializer,
      collections: ListingsSerializer,
      carts: CartSerializer,
      references: ReferenceSerializer
    };

    this.adapters = {
      products: ListingsAdapter,
      collections: ListingsAdapter,
      carts: LocalStorageAdapter,
      references: LocalStorageAdapter
    };
  },

  config: null,

  /**
   * Fetch all of a `type`, returning a promise.
   *
   * ```javascript
   * client.fetchAll('products').then(products => {
   *   // do things with products
   * });
   * ```
   *
   * @method fetchAll
   * @private
   * @param {String} type The pluralized name of the type, in lower case.
   * @return {Promise|Array} a promise resolving with an array of `type`
   */
  fetchAll(type) {
    const adapter = new this.adapters[type](this.config);

    return adapter.fetchMultiple(type).then(payload => {
      return this.deserialize(type, payload, adapter, null, { multiple: true });
    });
  },

  /**
   * Fetch one of a `type`, returning a promise.
   *
   * ```javascript
   * client.fetch('products', 123).then(product => {
   *   // do things with the product
   * });
   * ```
   *
   * @method fetch
   * @private
   * @param {String} type The pluralized name of the type, in lower case.
   * @param {String|Number} id a unique identifier
   * @return {Promise|BaseModel} a promise resolving with a single instance of
   * `type` expressed as a `BaseModel`.
   */
  fetch(type, id) {
    const adapter = new this.adapters[type](this.config);

    return adapter.fetchSingle(type, id).then(payload => {
      return this.deserialize(type, payload, adapter, null, { single: true });
    });
  },

  /**
   * Fetch many of a `type`, that match `query`
   *
   * ```javascript
   * client.fetchQuery('products', { collection_id: 456 }).then(products => {
   *   // do things with the products
   * });
   * ```
   *
   * @method fetchQuery
   * @private
   * @param {String} type The pluralized name of the type, in lower case.
   * @param {Object} query a query sent to the api server.
   * @return {Promise|Array} a promise resolving with an array of `type`.
   */
  fetchQuery(type, query) {
    const adapter = new this.adapters[type](this.config);

    return adapter.fetchMultiple(type, query).then(payload => {
      return this.deserialize(type, payload, adapter, null, { multiple: true });
    });
  },

  /**
   * Create an instance of `type`, optionally including `modelAttrs`.
   *
   * ```javascript
   * client.create('carts', { line_items: [ ... ] }).then(cart => {
   *   // do things with the cart.
   * });
   * ```
   *
   * @method create
   * @private
   * @param {String} type The pluralized name of the type, in lower case.
   * @param {Object} [modelAttrs={}] attributes representing the internal state
   * of the model to be persisted.
   * @return {Promise|CartModel} a promise resolving with a single instance of
   * `type`
   */
  create(type, modelAttrs = {}) {
    const adapter = new this.adapters[type](this.config);
    const serializer = new this.serializers[type](this.config);
    const Model = serializer.modelForType(type);
    const model = new Model(modelAttrs, { shopClient: this });
    const attrs = serializer.serialize(type, model);

    return adapter.create(type, attrs).then(payload => {
      return this.deserialize(type, payload, adapter, serializer, { single: true });
    });
  },

  /**
   * Create an instance of `type`, optionally including `attrs`.
   *
   * ```javascript
   * client.create('carts', { line_items: [ ... ] }).then(cart => {
   *   // do things with the cart.
   * });
   * ```
   *
   * @method update
   * @private
   * @param {String} type The pluralized name of the type, in lower case.
   * @param {BaseModel} updatedModel The model that represents new state to
   * to persist.
   * @return {Promise|CartModel} a promise resolving with a single instance of
   * `type`
   */
  update(type, updatedModel) {
    const adapter = updatedModel.adapter;
    const serializer = updatedModel.serializer;
    const serializedModel = serializer.serialize(type, updatedModel);
    const id = updatedModel.attrs[adapter.idKeyForType(type)];

    return adapter.update(type, id, serializedModel).then(payload => {
      return this.deserialize(type, payload, adapter, serializer, { single: true });
    });
  },

  /**
   * Proxy to serializer's deserialize.
   *
   * @method deserialize
   * @private
   * @param {String} type The pluralized name of the type, in lower case.
   * @param {Object} payload The raw payload returned by the adapter.
   * @param {BaseAdapter} adapter The adapter that yielded the payload.
   * @param {BaseSerializer} existingSerializer The serializer to attach. If
   * none is passed, then `this.deserialize` will create one for the type.
   * @param {Object} opts Options that determine which deserialization method to
   * use.
   * @param {Boolean} opts.multiple true when the payload represents multiple
   * models
   * @param {Boolean} opts.single true when the payload represents one model.
   * @return {BaseModel} an instance of `type` reified into a model.
   */
  deserialize(type, payload, adapter, existingSerializer, opts = {}) {
    const serializer = existingSerializer || new this.serializers[type](this.config);
    const meta = { shopClient: this, adapter, serializer, type };
    let serializedPayload;

    if (opts.multiple) {
      serializedPayload = serializer.deserializeMultiple(type, payload, meta);
    } else {
      serializedPayload = serializer.deserializeSingle(type, payload, meta);
    }

    return serializedPayload;
  },

  /**
    * Creates a {{#crossLink "CartModel"}}CartModel{{/crossLink}} instance.
    *
    * ```javascript
    * client.createCart().then(cart => {
    *   // do something with cart
    * });
    * ```
    *
    * @method createCart
    * @public
    * @return {Promise|CartModel} - new cart instance.
  */
  createCart(userAttrs = {}) {
    const baseAttrs = {
      line_items: []
    };
    const attrs = {};

    assign$1(attrs, baseAttrs);
    assign$1(attrs, userAttrs);

    return this.create('carts', attrs);
  },

  /**
    * Updates an existing {{#crossLink "CartModel"}}CartModel{{/crossLink}} instance and persists it to localStorage.
    *
    * ```javascript
    * client.createCart().then(cart => {
    *   cart.lineItems = [
    *     // ...
    *   ];
    *   client.updateCart(cart);
    * });
    * ```
    *
    * @param {CartModel} updatedCart an updated CartModel
    * @method updateCart
    * @private
    * @return {Promise|CartModel} - updated cart instance.
  */
  updateCart(updatedCart) {
    return this.update('carts', updatedCart);
  },

  /**
   * Retrieve a previously created cart by its key.
   *
   * ```javascript
   * client.fetchCart('shopify-buy.1459804699118.2').then(cart => {
   *   console.log(cart); // The retrieved cart
   * });
   *
   * @method fetchCart
   * @public
   * @param {String} id The cart's unique identifier
   * @return {Promise|CartModel} The cart model.
   *
   */
  fetchCart: fetchFactory('one', 'carts'),

  /**
   * This function will return an `Array` of products from your store
   * ```
   * client.fetchAllProducts()
   * .then(function(products) {
   *   // all products in store
   * });
   * ```
   *
   * @method fetchAllProducts
   * @public
   * @return {Promise|Array} The product models.
   */
  fetchAllProducts: fetchFactory('all', 'products'),

  /**
   * This function will return an `Array` of collections from your store
   * ```
   * client.fetchAllCollections()
   * .then(function(collections) {
   *
   * });
   * ```
   *
   * @method fetchAllCollections
   * @public
   * @return {Promise|Array} The collection models.
   */
  fetchAllCollections: fetchFactory('all', 'collections'),

  /**
   * Fetch one product by its ID.
   *
   * ```javascript
   * client.fetchProduct('8569911558').then(product => {
   *   console.log(product); // The product with an ID of '8569911558'
   * });
   * ```
   *
   * @method fetchProduct
   * @public
   * @param {String|Number} id a unique identifier
   * @return {Promise|BaseModel} The product model with the specified ID.
   */
  fetchProduct: fetchFactory('one', 'products'),

  /**
   * Fetch one collection by its ID.
   *
   * ```javascript
   * client.fetchCollection('336903494').then(collection => {
   *   console.log(collection); // The collection with an ID of '336903494'
   * });
   * ```
   *
   * @method fetchCollection
   * @public
   * @param {String|Number} id a unique identifier
   * @return {Promise|BaseModel} The collection model with the specified ID.
   */
  fetchCollection: fetchFactory('one', 'collections'),

  /**
   * Fetches a list of products matching a specified query.
   *
   * ```javascript
   * client.fetchQueryProducts({ collection_id: '336903494', tag: ['hats'] }).then(products => {
   *   console.log(products); // An array of products in collection '336903494' having the tag 'hats'
   * });
   * ```
   * @method fetchQueryProducts
   * @public
   * @param {Object} query A query sent to the api server containing one or more of:
   *   @param {String|Number} [query.collection_id] The ID of a collection to retrieve products from
   *   @param {Array} [query.tag] A list of tags to filter the products by. Accepts up to 10 tags.
   *   @param {Array} [query.product_ids] A list of product IDs to retrieve
   *   @param {String|Number} [query.page=1] The page offset number of the current lookup (based on the `limit`)
   *   @param {String|Number} [query.limit=50] The number of products to retrieve per page
   *   @param {String} [query.handle] The handle of the product to look up
   *   @param {String} [query.updated_at_min] Products updated since the supplied timestamp (format: 2008-12-31 03:00)
   *   @param {String} [query.sort_by] Will modify how products are ordered. Possible values are:
   *                                   `"updated_at"`, `"best-selling"`, `"title-ascending"`, `"title-descending"`,
   *                                   `"price-descending"`, `"price-ascending"`, `"created-descending"`, `"created-ascending"`,
   *                                   or `"collection-default"`. Using `"collection-default"` means that products will be ordered
   *                                   the using the custom ordering defined in your Shopify Admin. Default value `"collection-default"`.
   * @return {Promise|Array} The product models.
   */
  fetchQueryProducts: fetchFactory('query', 'products'),

  /**
   * Fetches a list of collections matching a specified query.
   *
   * ```javascript
   * client.fetchQueryCollections({page: 2, limit: 20}).then(collections => {
   *   console.log(collections); // An array of collection resources
   * });
   * ```
   *
   * @method fetchQueryCollections
   * @public
   * @param {Object} query a query sent to the api server.
   *   @param {String|Number} [query.page=1] the page offset number of the current lookup (based on the `limit`)
   *   @param {String|Number} [query.limit=50] the number of collections to retrieve per page
   * @return {Promise|Array} The collection models.
   */
  fetchQueryCollections: fetchFactory('query', 'collections'),

  /**
   * This method looks up a reference in localStorage to the most recent cart.
   * If one is not found, creates one. If the cart the reference points to
   * doesn't exist, create one and store the new reference.
   *
   * ```javascript
   * client.fetchRecentCart().then(cart => {
   *  // do stuff with the cart
   * });
   * ```
   *
   * @method fetchRecentCart
   * @public
   * @return {Promise|CartModel} The cart.
   */
  fetchRecentCart() {
    return this.fetch('references', `${ this.config.domain }.recent-cart`).then(reference => {
      const cartId = reference.referenceId;

      return this.fetchCart(cartId);
    })['catch'](() => {
      return this.createCart().then(cart => {
        const refAttrs = {
          referenceId: cart.id
        };

        refAttrs[GUID_KEY] = `${ this.config.domain }.recent-cart`;

        this.create('references', refAttrs);

        return cart;
      });
    });
  }
}, {
  serializers: {
    /**
     * @attribute
     * @default {
     *  products: ListingsAdapter,
     *  collections: ListingsAdapter,
     *  carts: CartAdapter
     * }
     * @type Object
     * @protected
     */
    // Prevent leaky state
    get: function () {
      return assign$1({}, this.shadowedSerializers);
    },
    set: function (values) {
      this.shadowedSerializers = assign$1({}, values);
    },
    configurable: true,
    enumerable: true
  },
  adapters: {
    get: function () {
      return assign$1({}, this.shadowedAdapters);
    },
    set: function (values) {
      this.shadowedAdapters = assign$1({}, values);
    },
    configurable: true,
    enumerable: true
  }
}));

/* globals require */

if (isNodeLikeEnvironment()) {
  /* this indirection is needed because babel throws errors when
   * transpiling require('node-fetch') using `amd` plugin with babel6
   */
  const localRequire = require;
  const fetch = localRequire('node-fetch');

  globalVars.set('fetch', fetch);
  globalVars.set('Response', fetch.Response);
}

/* global Buffer */

if (isNodeLikeEnvironment()) {
  globalVars.set('btoa', function (string) {
    return new Buffer(string).toString('base64');
  });
}

/**
 * @module shopify-buy
 * @submodule shopify
 */

/**
 * `ShopifyBuy` only defines one function {{#crossLink "ShopifyBuy/buildClient"}}{{/crossLink}} which can
 * be used to build a {{#crossLink "ShopClient"}}{{/crossLink}} to query your store using the
 * provided
 * {{#crossLink "ShopifyBuy/buildClient/configAttrs:apiKey"}}`apiKey`{{/crossLink}},
 * {{#crossLink "ShopifyBuy/buildClient/configAttrs:appId"}}`appId`{{/crossLink}},
 * and {{#crossLink "ShopifyBuy/buildClient/configAttrs:domain"}}`domain`{{/crossLink}}.
 * @class ShopifyBuy
 * @static
 */
const Shopify = {
  ShopClient,
  Config,
  version,
  NO_IMAGE_URI: NO_IMAGE_URI,

  /**
   * Create a ShopClient. This is the main entry point to the SDK.
   *
   * ```javascript
   * const client = ShopifyBuy.buildClient({
   *   apiKey: 'bf081e860bc9dc1ce0654fdfbc20892d',
   *   appId: 6,
   *   myShopifyDomain: 'your-shop-subdomain.myshopify.com', //Deprecated. Use `domain` instead
   *   domain: 'embeds.myshopify.com'
   * });
   * ```
   *
   * @method buildClient
   * @for ShopifyBuy
   * @static
   * @public
   * @param {Object} configAttrs An object of required config data such as: `apiKey`, `appId`, `domain`
   * @param {String} configAttrs.apiKey An API Key for your store. Documentation how to get an API Key:
   *                                    https://help.shopify.com/api/sdks/js-buy-sdk/getting-started#api-key
   * @param {String} configAttrs.appId Typically will be 6 which is the Buy Button App Id. For more info on App Id see:
   *                                   https://help.shopify.com/api/sdks/js-buy-sdk/getting-started#app-id
   * @param {String} configAttrs.domain Your shop's full `myshopify.com` domain. For example: `embeds.myshopify.com`
   * @param {String} configAttrs.myShopifyDomain You shop's `myshopify.com` domain. [deprecated Use configAttrs.domain]
   * @return {ShopClient} a client for the shop using your api credentials which you can use to query your store.
   */
  buildClient(configAttrs = {}) {
    const config = new this.Config(configAttrs);

    return new this.ShopClient(config);
  }
};

export default Shopify;
